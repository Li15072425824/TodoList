Todo项目核心链路（前端→Node→Redis）MD极简版

本文档为极简核心链路版，聚焦前端与后端、Redis的数据交互全流程，标注核心文件及问题排查点，适配接手者快速上手。

先运行 npm run dev 启动项目，浏览器访问 http://localhost:5173/ 即可查看结果。
然后运行 node api/server.js 启动Node服务，浏览器访问 http://localhost:3000/api/get-data 即可查看Redis数据。

# 一、核心数据流向图

```mermaid
flowchart TD
    A[前端Vue组件]:::component -->|调用方法| B[Pinia仓库src/stores/todo.js]:::store
    B -->|异步调用| C[API封装层src/api/redisData.js]:::api
    C -->|axios请求| D[Vite代理vite.config.js]:::proxy
    D -->|转发请求| E[本地NodeJS服务]:::node
    E -->|读写交互| F[Redis数据库]:::redis
    F -->|返回数据| E
    E -->|响应数据| D
    D -->|转发响应| C
    C -->|传递数据| B
    B -->|渲染数据| A

classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:2px
classDef store fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
classDef api fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
classDef proxy fill:#fff3e0,stroke:#ef6c00,stroke-width:2px
classDef node fill:#fce4ec,stroke:#c2185b,stroke-width:2px
classDef redis fill:#f1f8e9,stroke:#558b2f,stroke-width:2px
```

关键：仅初始化加载为前后端交互，其余操作均为前端内存操作。

# 二、核心文件清单（按优先级排序）

| 优先级 | 文件路径 | 核心职责 | 关键作用 |
|--------|----------|----------|----------|
| ★★★★★ | src/stores/todo.js | Pinia状态仓库 | 管理数据状态，调用API加载后端数据 |
| ★★★★★ | src/api/redisData.js | 前端请求封装 | 唯一后端请求出口，封装axios逻辑 |
| ★★★★☆ | vite.config.js | Vite代理配置 | 解决跨域，转发请求至Node服务 |
| ★★★☆☆ | TodoList.vue等组件 | 页面渲染交互 | 调用Pinia方法，仅负责视图展示 |
| ★★☆☆☆ | 本地NodeJS服务 | 后端中间层 | 与Redis交互，前端无需修改 |

# 三、核心文件精简代码

## 3.1 src/stores/todo.js（核心）

```javascript
import { defineStore } from 'pinia'
import { fetchRedisData } from '../api/redisData'

export const useTodoStore = defineStore('todo', {
  state: () => ({ todoList: [], filterType: 'all' }),
  getters: {
    filterTodoList() {
      switch (this.filterType) {
        case 'done': return this.todoList.filter(item => item.isDone)
        case 'undone': return this.todoList.filter(item => !item.isDone)
        default: return this.todoList
      }
    }
  },
  actions: {
    // 唯一加载Redis数据的方法
    async initTodoList() {
      const data = await fetchRedisData()
      this.todoList = data.redis_get_result || data.data?.value || []
    },
    // 纯前端操作
    addTodo(content) {
      content.trim() && this.todoList.unshift({ id: Date.now(), content: content.trim(), isDone: false })
    },
    toggleTodoDone(id) {
      const todo = this.todoList.find(item => item.id === id)
      todo && (todo.isDone = !todo.isDone)
    },
    deleteTodo(id) { this.todoList = this.todoList.filter(item => item.id !== id) },
    changeFilter(type) { this.filterType = type },
    clearAllTodo() { this.todoList = [] }
  }
})
```

## 3.2 src/api/redisData.js

```javascript
import axios from 'axios';

// 唯一请求Redis数据的方法
export const fetchRedisData = async () => {
  const response = await axios.get('/api/get-data');
  return response.data;
};
```

## 3.3 vite.config.js（核心代理）

```javascript
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

export default defineConfig({
  plugins: [vue()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:3000', // 对应Node服务地址
        changeOrigin: true // 必开跨域
      }
    }
  }
})
```

# 四、核心问题排查指南

```mermaid
flowchart LR
    问题分类 --> 数据加载失败[数据加载空白/无数据]
    问题分类 --> 请求报错[请求404/500/跨域]
    问题分类 --> 响应异常[请求无响应/数据异常]
    
    数据加载失败 -->|检查| A[Pinia的initTodoList]
    A --> A1[是否调用fetchRedisData]
    A --> A2[赋值逻辑是否匹配Node返回格式]
    
    请求报错 -->|检查| B[Vite代理配置]
    B --> B1[target是否对应Node地址]
    B --> B2[changeOrigin是否为true]
    
    响应异常 -->|检查| C[API封装]
    C --> C1[请求地址是否为/api/get-data]
    C --> C2[是否正确抛出异常]
    
    A2 --> 方案1[调整赋值逻辑，匹配Node返回结构]
    B2 --> 方案2[修正target，确保Node正常启动]
    C2 --> 方案3[核对地址，补充异常抛出]

classDef question fill:#e1f5fe,stroke:#0277bd
classDef check fill:#f3e5f5,stroke:#7b1fa2
classDef solve fill:#e8f5e8,stroke:#2e7d32

class 数据加载失败,请求报错,响应异常 question
class A,B,C,A1,A2,B1,B2,C1,C2 check
class 方案1,方案2,方案3 solve
```

# 五、接手快速上手3步流程

1. 理清数据流向：对照上述流向图，明确数据从Redis到前端的完整路径。

2. 定位核心文件：聚焦3个核心文件（Pinia仓库、API封装、代理配置）。

3. 聚焦核心操作：
        

  - 加载Redis数据：关注initTodoList与fetchRedisData方法。

  - 调整请求链路：修改API地址与Vite代理配置。

  - 修改业务逻辑：仅操作Pinia的actions方法，无需改动后端。

# 六、补充说明

- 前端Todo数据唯一后端来源：initTodoList调用fetchRedisData加载。

- 仅初始化加载同步Redis，其余操作均为前端内存操作。

- Node服务为中间层，前端只需确保其启动且地址与代理一致。
